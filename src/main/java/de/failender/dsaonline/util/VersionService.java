// Generated by delombok at Thu Nov 22 18:54:11 CET 2018
package de.failender.dsaonline.util;

import de.failender.dsaonline.data.entity.HeldEntity;
import de.failender.dsaonline.data.entity.UserEntity;
import de.failender.dsaonline.data.entity.VersionEntity;
import de.failender.dsaonline.data.repository.UserRepository;
import de.failender.dsaonline.data.service.HeldRepositoryService;
import de.failender.dsaonline.data.service.VersionRepositoryService;
import de.failender.dsaonline.rest.dto.HeldVersion;
import de.failender.dsaonline.service.HeldenService;
import de.failender.heldensoftware.api.HeldenApi;
import de.failender.heldensoftware.api.authentication.TokenAuthentication;
import de.failender.heldensoftware.api.requests.*;
import de.failender.heldensoftware.xml.datenxml.Daten;
import de.failender.heldensoftware.xml.datenxml.Ereignis;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.UUID;

@Service
public class VersionService {

	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(VersionService.class);
	private final HeldRepositoryService heldRepositoryService;
	private final VersionRepositoryService versionRepositoryService;
	private final HeldenApi heldenApi;
	private final UserRepository userRepository;
	private final HeldenService heldenService;

	public VersionService(HeldRepositoryService heldRepositoryService, VersionRepositoryService versionRepositoryService, HeldenApi heldenApi, UserRepository userRepository, HeldenService heldenService) {
		this.heldRepositoryService = heldRepositoryService;
		this.versionRepositoryService = versionRepositoryService;
		this.heldenApi = heldenApi;
		this.userRepository = userRepository;
		this.heldenService = heldenService;
	}

	private void saveDatenXml(InputStream is, BigInteger heldid, UUID cacheId) {
		ReturnHeldDatenWithEreignisseRequest req = new ReturnHeldDatenWithEreignisseRequest(heldid, null, cacheId);
		heldenApi.getCacheHandler().doCache(req, is);
	}

	private void saveHeldenXml(InputStream is, BigInteger heldid, UUID cacheId) {
		ReturnHeldXmlRequest req = new ReturnHeldXmlRequest(heldid, null, cacheId);
		heldenApi.getCacheHandler().doCache(req, is);
	}

	private void savePdf(InputStream is, BigInteger heldid, UUID cacheId) {
		ReturnHeldPdfRequest req = new ReturnHeldPdfRequest(heldid, null, cacheId);
		heldenApi.getCacheHandler().doCache(req, is);
	}

	public String saveHeld(BigInteger id, String xml) {
		Tuple2<InputStream, InputStream> converted = Mono.zip(heldenApi.requestRaw(new ConvertingRequest(HeldenApi.Format.datenxml, xml), true), heldenApi.requestRaw(new ConvertingRequest(HeldenApi.Format.pdfintern, xml), true)).block();
		HeldEntity held = heldRepositoryService.findHeld(id);
		long key = XmlUtil.getKeyFromString(xml);
		if(held.getKey() != key) {
			return "Hochgeladener Held unterscheidet sich von dem ausgew√§hlten Helden";
		}
		Date stand = XmlUtil.getStandFromString(xml);
		if (versionRepositoryService.findVersionByHeldidAndCreated(held, stand).isPresent()) {
			return "Held ist bereits in der selben Version vorhanden";
		}
		String message = null;
		UserEntity userEntity = userRepository.findById(held.getUserId()).get();
		List<HeldVersion> heldVersions = heldenService.loadHeldenVersionen(id);
		HeldVersion latestVersion = heldVersions.get(0);
		HeldVersion firstVersionToMove = heldVersions.stream().filter(version -> version.getDatum().getTime() >= stand.getTime()).sorted(Comparator.comparingLong(a -> a.getDatum().getTime())).findFirst().orElse(null);
		int firstVersionToMoveInt = firstVersionToMove == null ? latestVersion.getVersion() + 1 : firstVersionToMove.getVersion();
		if (firstVersionToMove == null) {
			log.warn("Held that should get faked is newer then the newest one currently uploaded");
			heldenApi.request(new UpdateXmlRequest(new TokenAuthentication(userEntity.getToken()), xml))
					.block();
			message = "Held ist neuer als die neuste Online-Version. Held mit Helden-Online synchronisiert";
		} else {
			for (int i = latestVersion.getVersion(); i >= firstVersionToMoveInt; i--) {
				VersionEntity versionEntity = versionRepositoryService.findVersion(held, i);
				versionEntity.setVersion(i + 1);
				versionRepositoryService.saveVersionAndFlush(held, versionEntity);
			}
		}
		UUID uuid = UUID.randomUUID();
		saveHeldenXml(new ByteArrayInputStream(xml.getBytes()), id, uuid);
		saveDatenXml(converted.getT1(), id, uuid);
		//No need to use authentication here since the file is coming from cache
		Daten daten = heldenApi.request(new ReturnHeldDatenWithEreignisseRequest(id, null, uuid)).block();
		savePdf(converted.getT2(), id, uuid);
		persistVersion(held, userEntity, firstVersionToMoveInt, xml, uuid, daten);
		return message;
	}

	public VersionEntity persistVersion(HeldEntity held, UserEntity user, int version, String xml, UUID uuid, Daten daten) {
		Date date = XmlUtil.getStandFromString(xml);
		VersionEntity versionEntity = new VersionEntity();
		versionEntity.setVersion(version);
		versionEntity.setHeldid(held.getId());
		versionEntity.setCacheId(uuid);
		versionEntity.setCreatedDate(date);
		versionEntity.setLastEvent(extractLastEreignisString(daten.getEreignisse().getEreignis()));
		versionEntity.setAp(daten.getAngaben().getAp().getGesamt().intValue());
		versionEntity = this.versionRepositoryService.saveVersion(held, versionEntity);


		return versionEntity;
	}

	public boolean validateVersion(HeldEntity heldEntity) {
		int pre= -1;
		boolean result = true;
		for(VersionEntity versionEntity: versionRepositoryService.findVersionsForHeldDescending(heldEntity)) {
			if(versionEntity.getVersion() == pre) {
				result = false;
				log.error("Error while validating version", new RuntimeException("Error while persisting version! Version " + pre + " for held " + heldEntity.getName() + ":" + heldEntity.getId() +  " is duplicated"));
			}
			pre = versionEntity.getVersion();
		}

		return result;

	}

	public static String extractLastEreignisString(List<Ereignis> ereignisse) {
		Ereignis ereignis = extractLastEreignis(ereignisse);
		if (ereignis == null) {
			return null;
		}
		String s = ereignis.getKommentar();
		int index = s.indexOf("Gesamt AP");
		if (index == -1) {
			return s;
		}
		s = s.substring(0, index);
		return s;
	}

	public static Ereignis extractLastEreignis(List<Ereignis> ereignisse) {
		for (int i = ereignisse.size() - 1; i >= 0; i--) {
			if (ereignisse.get(i).getAp() > 0) {
				return ereignisse.get(i);
			}
		}
		return null;
	}
}
