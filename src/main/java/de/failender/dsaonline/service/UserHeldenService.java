// Generated by delombok at Thu Nov 22 18:54:11 CET 2018
package de.failender.dsaonline.service;

import de.failender.dsaonline.data.entity.HeldEntity;
import de.failender.dsaonline.data.entity.UserEntity;
import de.failender.dsaonline.data.entity.VersionEntity;
import de.failender.dsaonline.data.repository.UserRepository;
import de.failender.dsaonline.data.service.HeldRepositoryService;
import de.failender.dsaonline.data.service.VersionRepositoryService;
import de.failender.dsaonline.util.VersionService;
import de.failender.dsaonline.util.XmlUtil;
import de.failender.heldensoftware.api.HeldenApi;
import de.failender.heldensoftware.api.authentication.TokenAuthentication;
import de.failender.heldensoftware.api.requests.GetAllHeldenRequest;
import de.failender.heldensoftware.api.requests.ReturnHeldDatenWithEreignisseRequest;
import de.failender.heldensoftware.api.requests.ReturnHeldPdfRequest;
import de.failender.heldensoftware.api.requests.ReturnHeldXmlRequest;
import de.failender.heldensoftware.xml.datenxml.Daten;
import de.failender.heldensoftware.xml.datenxml.Ereignis;
import de.failender.heldensoftware.xml.heldenliste.Held;
import org.apache.commons.io.IOUtils;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple3;

import java.io.InputStream;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
public class UserHeldenService {

	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(UserHeldenService.class);
	private final UserRepository userRepository;
	private final HeldenApi heldenApi;
	private final HeldRepositoryService heldRepositoryService;
	private final VersionService versionService;
	private final VersionRepositoryService versionRepositoryService;

	public UserHeldenService(UserRepository userRepository, HeldenApi heldenApi, HeldRepositoryService heldRepositoryService, VersionService versionService, VersionRepositoryService versionRepositoryService) {
		this.versionService = versionService;
		this.versionRepositoryService = versionRepositoryService;
		this.userRepository = userRepository;
		this.heldenApi = heldenApi;
		this.heldRepositoryService = heldRepositoryService;
	}

	public void updateHeldenForUser(UserEntity userEntity, List<Held> helden, boolean ignoreLocks) {
		log.debug("Updating helden for user {}, online found {}", userEntity.getName(), helden.size());
		heldRepositoryService.findByUserId(userEntity.getId()).forEach(heldEntity -> {

			Optional<Held> heldOptional = helden.stream().filter(_held -> _held.getHeldenid().equals(heldEntity.getId())).findFirst();
			if (!heldOptional.isPresent()) {
				log.debug("Held with Name {} is no longer online, disabling it", heldEntity.getName());
				heldEntity.setDeleted(true);
				heldRepositoryService.saveHeld(heldEntity);
			} else {
				if (heldEntity.isDeleted()) {
					heldEntity.setDeleted(false);
					heldRepositoryService.saveHeld(heldEntity);
				}
				Held xmlHeld = heldOptional.get();
				helden.remove(xmlHeld);
				if(heldEntity.getLockExpire() != null && heldEntity.getLockExpire().getTime() > System.currentTimeMillis() && !ignoreLocks) {
					log.info("Ignoring update for held {} {} since it is locked. It will unlock at {}", heldEntity.getName(), heldEntity.getId(), heldEntity.getLockExpire().toString());
					return;
				}
				VersionEntity versionEntity = versionRepositoryService.findLatestVersion(heldEntity);
				if (isOnlineVersionOlder(xmlHeld, versionEntity.getCreatedDate())) {
					log.info("Got a new version for held with name {}", heldEntity.getName());
					//We got a new version of this xmlHeld
					UUID uuid = UUID.randomUUID();
					//Fetch all the data before creating the version, to make sure the helden-api doesnt fail
					Tuple3<String, Daten, InputStream> data = Mono.zip(
							heldenApi.request(new ReturnHeldXmlRequest(xmlHeld.getHeldenid(), new TokenAuthentication(userEntity.getToken()), uuid)),
							heldenApi.request(new ReturnHeldDatenWithEreignisseRequest(heldEntity.getId(), new TokenAuthentication(userEntity.getToken()), uuid), false),
							heldenApi.request(new ReturnHeldPdfRequest(heldEntity.getId(), new TokenAuthentication(userEntity.getToken()), uuid), false)).block();
					IOUtils.closeQuietly(data.getT3());
					String xml = data.getT1();
					this.versionService.persistVersion(heldEntity, userEntity, versionEntity.getVersion() + 1, xml, uuid, data.getT2());
				} else {
					log.debug("Held with Name {} is already on latest version", heldEntity.getName());
				}
			}
		});
		helden.forEach(held -> {
			UUID uuid = UUID.randomUUID();
			Tuple3<String, Daten, InputStream> data = Mono.zip(
					heldenApi.request(new ReturnHeldXmlRequest(held.getHeldenid(), new TokenAuthentication(userEntity.getToken()), uuid)),
					heldenApi.request(new ReturnHeldDatenWithEreignisseRequest(held.getHeldenid(), new TokenAuthentication(userEntity.getToken()), uuid)),
					heldenApi.request(new ReturnHeldPdfRequest(held.getHeldenid(), new TokenAuthentication(userEntity.getToken()), uuid))).block();
			IOUtils.closeQuietly(data.getT3());
			String xml = data.getT1();
			HeldEntity heldEntity = new HeldEntity();
			heldEntity.setGruppe(userEntity.getGruppe());
			heldEntity.setName(held.getName());
			heldEntity.setCreatedDate(new Date());
			heldEntity.setId(held.getHeldenid());
			heldEntity.setUserId(userEntity.getId());
			heldEntity.setKey(XmlUtil.getKeyFromString(xml));
			heldEntity = heldRepositoryService.saveHeld(heldEntity);
			versionService.persistVersion(heldEntity, userEntity, 1, xml, uuid, data.getT2());
			log.info("Saving new held {} for user {} with version {}", heldEntity.getName(), userEntity.getName(), 1);
		});
	}

	public void updateHeldenForToken(String token) {
		updateHeldenForUser(userRepository.findByToken(token), true);
	}

	public void updateHeldenForUser(UserEntity userEntity, boolean cache) {
		this.updateHeldenForUser(userEntity, cache, false);
	}

	public void updateHeldenForUser(UserEntity userEntity, boolean cache, boolean ignoreLocks) {
		if (userEntity.getToken() == null) {
			log.error("User with getName {} has null token ", userEntity.getName());
			return;
		}
		List<Held> helden = heldenApi.request(new GetAllHeldenRequest(new TokenAuthentication(userEntity.getToken())), cache).block().getHeld();
		this.updateHeldenForUser(userEntity, helden, ignoreLocks);
	}

	private boolean isOnlineVersionOlder(Held xmlHeld, Date heldCreatedDate) {
		Date lastEditedDate = new Date((xmlHeld.getHeldlastchange().longValue() / 1000L) * 1000L);
		if (lastEditedDate.getTime() == heldCreatedDate.getTime()) {
			return false;
		}
		return lastEditedDate.after(heldCreatedDate);
	}


	public void forceUpdateHeldenForUser(UserEntity userEntity) {
		log.info("Refreshing helden for user {}", userEntity.getName());
		if (userEntity.getToken() != null) {
			this.updateHeldenForUser(userEntity, false);
		}
	}

	public void forceUpdateHeldenForUser(UserEntity userEntity, boolean ignoreLocks) {
		log.info("Refreshing helden for user {}", userEntity.getName());
		if (userEntity.getToken() != null) {
			this.updateHeldenForUser(userEntity, false, ignoreLocks);
		}
	}



	public static void clearEreigniskontrolle(List<Ereignis> ereignisse) {
		if (ereignisse.isEmpty()) {
			return;
		}
		Ereignis ereignis = ereignisse.get(ereignisse.size() - 1);
		if (ereignis.getAktion() == null) {
			return;
		}
		if (ereignis.getAktion().equals("Ã„nderungskontrolle")) {
			ereignisse.remove(ereignisse.size() - 1);
		}
	}
}
