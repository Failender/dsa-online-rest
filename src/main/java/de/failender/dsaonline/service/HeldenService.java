// Generated by delombok at Thu Nov 22 18:54:11 CET 2018
package de.failender.dsaonline.service;

import de.failender.dsaonline.data.entity.*;
import de.failender.dsaonline.data.repository.FavTalentRepository;
import de.failender.dsaonline.data.repository.LagerortRepository;
import de.failender.dsaonline.data.repository.UserRepository;
import de.failender.dsaonline.data.service.HeldRepositoryService;
import de.failender.dsaonline.data.service.VersionRepositoryService;
import de.failender.dsaonline.exceptions.NoWritePermissionException;
import de.failender.dsaonline.rest.dto.*;
import de.failender.dsaonline.security.SecurityUtils;
import de.failender.dsaonline.util.XmlUtil;
import de.failender.heldensoftware.Unterscheidbar;
import de.failender.heldensoftware.api.HeldenApi;
import de.failender.heldensoftware.api.authentication.TokenAuthentication;
import de.failender.heldensoftware.api.requests.ReturnHeldDatenWithEreignisseRequest;
import de.failender.heldensoftware.api.requests.ReturnHeldPdfRequest;
import de.failender.heldensoftware.api.requests.ReturnHeldXmlRequest;
import de.failender.heldensoftware.api.requests.UpdateXmlRequest;
import de.failender.heldensoftware.xml.datenxml.Daten;
import de.failender.heldensoftware.xml.datenxml.Eigenschaftswerte;
import de.failender.heldensoftware.xml.datenxml.Ereignis;
import one.util.streamex.EntryStream;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import reactor.core.publisher.Flux;
import reactor.util.function.Tuple2;

import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.TransformerException;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Service
public class HeldenService {

	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(HeldenService.class);
	private final HeldRepositoryService heldRepositoryService;
	private final HeldenApi heldenApi;
	private final UserRepository userRepository;
	private final VersionRepositoryService versionRepositoryService;
	private final SecurityUtils securityUtils;
	private final LagerortRepository lagerortRepository;
	private final FavTalentRepository favTalentRepository;

	public HeldenService(HeldRepositoryService heldRepositoryService, HeldenApi heldenApi, UserRepository userRepository, VersionRepositoryService versionRepositoryService, SecurityUtils securityUtils, LagerortRepository lagerortRepository, FavTalentRepository favTalentRepository) {
		this.heldRepositoryService = heldRepositoryService;
		this.heldenApi = heldenApi;
		this.userRepository = userRepository;
		this.versionRepositoryService = versionRepositoryService;
		this.securityUtils = securityUtils;
		this.lagerortRepository = lagerortRepository;
		this.favTalentRepository = favTalentRepository;
	}

	public List<HeldenInfo> getAllHeldenForCurrentUser() {
		UserEntity user = SecurityUtils.getCurrentUser();
		return heldRepositoryService.findByUserId(user.getId()).stream().map(held -> heldRepositoryService.findHeldWithLatestVersion(held)).map(this::mapToHeldenInfo).collect(Collectors.toList());
	}

	public Daten findHeldWithLatestVersion(BigInteger id) {
		HeldWithVersion heldWithVersion = heldRepositoryService.findHeldWithLatestVersion(id);
		return getHeldenDaten(id, heldWithVersion.getVersion().getVersion()).getDaten();
	}

	public HeldenInfo mapToHeldenInfo(HeldWithVersion heldWithVersion) {
		return new HeldenInfo(heldWithVersion.getHeld().getName(), heldWithVersion.getVersion().getCreatedDate(), heldWithVersion.getVersion().getVersion(), heldWithVersion.getHeld().getGruppe().getName(), heldWithVersion.getHeld().getId(), heldWithVersion.getHeld().isPublic(), heldWithVersion.getHeld().isActive());
	}

	public DatenAndEditable getHeldenDaten(BigInteger id, int version) {
		HeldEntity held = heldRepositoryService.findHeld(id);
		VersionEntity versionEntity = versionRepositoryService.findVersion(held, version);
		UserEntity owningUser = this.userRepository.findById(held.getUserId()).get();
		boolean isOwnHeld = false;
		if(SecurityUtils.isLoggedIn()) {
			isOwnHeld = SecurityUtils.getCurrentUser().getId() == owningUser.getId();
		}
		Daten daten = heldenApi.request(new ReturnHeldDatenWithEreignisseRequest(id, new TokenAuthentication(owningUser.getToken()), versionEntity.getCacheId()), true).block();
		return new DatenAndEditable(daten, securityUtils.canCurrentUserEditHeldBool(held), owningUser.isCanWrite(), isOwnHeld);
	}

	public Differences calculateDifferences(BigInteger heldenid, int from, int to) {
		//If from is bigger then to flip the values
		if (from > to) {
			int tempFrom = from;
			from = to;
			to = tempFrom;
		}
		HeldEntity held = heldRepositoryService.findHeld(heldenid);
		VersionEntity fromVersion = versionRepositoryService.findVersion(held, from);
		VersionEntity toVersion = versionRepositoryService.findVersion(held, to);
		return this.calculateDifferences(held, fromVersion, toVersion);
	}

	private Differences calculateDifferences(HeldEntity held, VersionEntity from, VersionEntity to) {
		Tuple2<Daten, Daten> datenTuple = heldenApi.request(new ReturnHeldDatenWithEreignisseRequest(held.getId(), null, from.getCacheId())).zipWith(heldenApi.request(new ReturnHeldDatenWithEreignisseRequest(held.getId(), null, to.getCacheId()))).block();
		return calculateDifferences(held.getName(), datenTuple.getT1(), datenTuple.getT2());
	}

	private Differences calculateDifferences(String name, Daten from, Daten to) {
		//List of all ereignisse that are not in from but in to
		List<Ereignis> ereignisList = to.getEreignisse().getEreignis().subList(from.getEreignisse().getEreignis().size(), to.getEreignisse().getEreignis().size());
		Map<String, List<Ereignis>> map = EntryStream.of(ereignisList).mapToKey((idx, ereignis) -> ereignis.getObject().replaceFirst("Sprachen kennen ", "").replaceFirst("Lesen/Schreiben", "L/S").replaceFirst("Ritualkenntnis: ", "").replaceAll(" \\[.*\\]", "")).grouping();
		return new Differences(name, calculateDifference(from.getTalentliste().getTalent(), to.getTalentliste().getTalent(), map, true),
				calculateDifference(from.getZauberliste().getZauber(), to.getZauberliste().getZauber(), map, true),
				calculateDifference(from.getVorteile().getVorteil(), to.getVorteile().getVorteil(), map, false),
				calculateEigenschaftDifference(from, to, map),
				calculateSonderfertigkeitenDifference(ereignisList));
	}

	private List<Difference> calculateEigenschaftDifference(Daten from, Daten to, Map<String, List<Ereignis>> ereignis) {
		return Stream.of(calculateEigenschaftDifference(from.getEigenschaften().getMut(), to.getEigenschaften().getMut(), ereignis), calculateEigenschaftDifference(from.getEigenschaften().getKlugheit(), to.getEigenschaften().getKlugheit(), ereignis), calculateEigenschaftDifference(from.getEigenschaften().getIntuition(), to.getEigenschaften().getIntuition(), ereignis), calculateEigenschaftDifference(from.getEigenschaften().getCharisma(), to.getEigenschaften().getCharisma(), ereignis), calculateEigenschaftDifference(from.getEigenschaften().getFingerfertigkeit(), to.getEigenschaften().getFingerfertigkeit(), ereignis), calculateEigenschaftDifference(from.getEigenschaften().getGewandtheit(), to.getEigenschaften().getGewandtheit(), ereignis), calculateEigenschaftDifference(from.getEigenschaften().getKonstitution(), to.getEigenschaften().getKonstitution(), ereignis), calculateEigenschaftDifference(from.getEigenschaften().getKoerperkraft(), to.getEigenschaften().getKoerperkraft(), ereignis)).filter(Objects::nonNull).collect(Collectors.toList());
	}

	private List<Difference> calculateSonderfertigkeitenDifference(List<Ereignis> ereignis) {
		List<Difference> differences = new ArrayList<>();
		for (Ereignis ereigni : ereignis) {
			if(ereigni.getAktion().startsWith("Sonderfertigkeit")) {
				differences.add(new Difference(-ereigni.getAp(), "aktiv", ereigni.getObject(), ereigni.getKommentar()));
			}
		}
		return differences;
	}

	private Difference calculateEigenschaftDifference(Eigenschaftswerte from, Eigenschaftswerte to, Map<String, List<Ereignis>> map) {
		if (from.getAkt().equals(to.getAkt())) {
			return null;
		}
		String name = from.getName();
		int fromVal = from.getAkt().intValue();
		int toVal = to.getAkt().intValue();
		String tooltip = calculateTooltip(map, name, false);
		return new Difference(fromVal, toVal, name, tooltip);
	}

	private List<Difference> calculateDifference(List<? extends Unterscheidbar> fromList, List<? extends Unterscheidbar> toList, Map<String, List<Ereignis>> ereignisse, boolean replaceSpace) {
		List<Difference> differences = new ArrayList<>();
		fromList.forEach(from -> {
			Optional<? extends Unterscheidbar> toOptional = toList.stream().filter(to -> to.name().equals(from.name())).findFirst();
			if (toOptional.isPresent()) {
				Unterscheidbar to = toOptional.get();
				toList.remove(to);
				Integer fromWert = from.getWert();
				Integer toWert = to.getWert();
				if (fromWert == null && toWert == null || fromWert != null && toWert != null && fromWert.equals(toWert)) {
					return;
				}
				differences.add(new Difference(fromWert, toWert, from.name(), ""));
			} else {
				differences.add(new Difference(from.getWert(), null, from.name(), ""));
			}
		});
		toList.forEach(toTalent -> differences.add(new Difference(null, toTalent.getWert(), toTalent.name(), "")));
		differences.forEach(difference -> {
			String tooltip = calculateTooltip(ereignisse, difference.getName(), replaceSpace);
			difference.setTooltip(tooltip);
		});
		return differences;
	}

	private String calculateTooltip(Map<String, List<Ereignis>> map, String name, boolean replaceSpace) {
		return map.getOrDefault(name, Collections.emptyList()).stream().map(ereignis -> ereignis.getBemerkung().replace(",", "")).map(value -> {
			if (replaceSpace && value.isEmpty()) {
				return "Aktiviert";
			} else {
				return value;
			}
		}).collect(Collectors.joining(", "));
	}

	public List<HeldVersion> loadHeldenVersionen(BigInteger heldenid) {
		List<VersionEntity> versionen = versionRepositoryService.findVersionsForHeldDescending(heldRepositoryService.findHeld(heldenid));
		return versionen.stream().map(version -> new HeldVersion(version.getLastEvent(), version.getCreatedDate(), version.getVersion())).collect(Collectors.toList());
	}

	public void providePdfDownload(BigInteger id, int version, HttpServletResponse response) {
		HeldEntity held = heldRepositoryService.findHeld(id);
		VersionEntity versionEntity = versionRepositoryService.findVersion(held, version);
		heldenApi.provideDownload(new ReturnHeldPdfRequest(id, null, versionEntity.getCacheId()), response);
	}

	public void provideXmlDownload(BigInteger id, int version, HttpServletResponse response) {
		//Force view permission check
		HeldEntity held = heldRepositoryService.findHeld(id);
		VersionEntity versionEntity = versionRepositoryService.findVersion(held, version);
		heldenApi.provideDownload(new ReturnHeldXmlRequest(id, null, versionEntity.getCacheId()), response);
	}

	public void updateHeldenPublic(boolean isPublic, BigInteger heldid) {
		log.info("Updating public status for held {}: {}", heldid, isPublic);
		heldRepositoryService.updateHeldenPublic(isPublic, heldid);
	}

	public void updateHeldenActive(boolean isActive, BigInteger heldid) {
		log.info("Updating active status for held {}: {}", heldid, isActive);
		heldRepositoryService.updateHeldenActive(isActive, heldid);
	}

	public List<Daten> findPublicByGruppeId(Integer gruppeId) {
		return heldRepositoryService.findByGruppeId(gruppeId).stream().filter(HeldEntity::isPublic).map(HeldEntity::getId).map(this::findHeldWithLatestVersion).collect(Collectors.toList());
	}

	public List<Daten> findPublicActiveByGruppeId(Integer gruppeId) {
		return heldRepositoryService.findByGruppeId(gruppeId)
				.stream()
				.filter(HeldEntity::isPublic)
				.filter(HeldEntity::isActive)
				.map(HeldEntity::getId)
				.map(this::findHeldWithLatestVersion).collect(Collectors.toList());
	}

	public List<Daten> findAllByGruppeId(Integer gruppeId) {
		SecurityUtils.checkRight(SecurityUtils.VIEW_ALL);
		return heldRepositoryService.findByGruppeId(gruppeId).stream().map(HeldEntity::getId).map(this::findHeldWithLatestVersion).collect(Collectors.toList());
	}

	public List<BigInteger> getAllHeldenIds() {
		return heldRepositoryService.getAllHeldenIds();
	}

	public void provideXmlFullDownload(BigInteger heldid, HttpServletResponse response) {
		response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);
		response.setHeader("Content-disposition", "attachment; filename=versionen.zip");
		ZipOutputStream zos;
		try {
			zos = new ZipOutputStream(response.getOutputStream());
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		List<VersionEntity> versions = versionRepositoryService.findVersions(heldRepositoryService.findHeld(heldid));
		Flux.fromIterable(versions).flatMap(version -> heldenApi.requestRaw(new ReturnHeldXmlRequest(heldid, null, version.getCacheId()), true)).zipWith(Flux.range(1, versions.size())).doOnNext(tuple -> {
			try {
				zos.putNextEntry(new ZipEntry(tuple.getT2() + ".xml"));
				org.apache.commons.io.IOUtils.copy(tuple.getT1(), zos);
				tuple.getT1().close();
				zos.closeEntry();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}).blockLast();
		org.apache.commons.io.IOUtils.closeQuietly(zos);
	}

	public void deleteVersion(BigInteger heldid, int version) {
		HeldEntity held = heldRepositoryService.findHeld(heldid);
		versionRepositoryService.deleteVersion(held, version);
	}

	private Element getItemsElement(HeldWithVersion heldWithVersion) {
		String xml = heldenApi.request(new ReturnHeldXmlRequest(heldWithVersion.getHeld().getId(), SecurityUtils.getAuthentication(), heldWithVersion.getVersion().getCacheId()))
				.block();
		Element held = XmlUtil.getHeldFromXml(xml);
		return (Element) held.getElementsByTagName("gegenstände").item(0);
	}

	public List<Gegenstand> getInventar(BigInteger heldid) {
		List<Gegenstand> values = new ArrayList<>();
		Element items = getItemsElement(heldRepositoryService.findHeldWithLatestVersion(heldid));
		outer:
		for(int i = 0; i<items.getChildNodes().getLength(); i++) {
			Node node = items.getChildNodes().item(i);
			if(!(node instanceof Element)) {
				continue;
			}
			values.add(parseGegenstand(node));
		}
		tryComputeLagerorte(values, heldid);
		return values;
	}

	private Gegenstand parseGegenstand(Node node) {
		return parseGegenstand((Element)node);
	}

	private Gegenstand parseGegenstand(Element gegenstand) {
		int anzahl = Integer.valueOf(gegenstand.getAttribute("anzahl"));
		if(gegenstand.getChildNodes().getLength() == 0 ) {
			return new Gegenstand(gegenstand.getAttribute("name"), anzahl, true);
		} else {
			for (int j = 0; j < gegenstand.getChildNodes().getLength(); j++) {
				Node n = gegenstand.getChildNodes().item(j);
				if (!(n instanceof Element)) {
					continue;
				}
				Element modallgemein = (Element) n;
				if (!modallgemein.getTagName().equals("modallgemein")) {
					continue;
				}

				for (int k = 0; k < modallgemein.getChildNodes().getLength(); k++) {
					Node no = modallgemein.getChildNodes().item(k);
					if (!(no instanceof Element)) {
						continue;
					}
					Element e = (Element) no;
					if (!((Element) no).getTagName().equals("name")) {
						continue;
					}
					String name = e.getAttribute("value");
					return new Gegenstand(name, anzahl, true);


				}
			}
			return new Gegenstand(gegenstand.getAttribute("name"), anzahl, true);
		}
	}

	private void tryComputeLagerorte(List<Gegenstand> items, BigInteger heldid) {
	    List<LagerortEntity> lagerorte = lagerortRepository.findByHeldid(heldid);
        for (LagerortEntity lagerortEntity : lagerorte) {
            List<GegenstandLagerort> removal = new ArrayList<>();
            for (GegenstandLagerort gl : lagerortEntity.getGegenstandLagerorte()) {
                List<Gegenstand> matches = items.stream()
                        .filter(i -> i.getGegenstand().equals(gl.getName()))
                        .collect(Collectors.toList());
                if(matches.isEmpty()) {
                    removal.add(gl);
                    return;
                }
                if(matches.size() == 1) {
                    matches.get(0).setLagerort(lagerortEntity.getName());
                    continue;
                }
                List<Gegenstand> preciseMatches = matches
                        .stream()
                        .filter(g -> g.getAnzahl() == gl.getAmount())
                        .collect(Collectors.toList());
                if(preciseMatches.size() == 1) {
                    preciseMatches.get(0).setLagerort(lagerortEntity.getName());
                    continue;
                }
                // If this happens we cant be sure where to place this item.
                // Leave it as is until we find a better solution for precisley matching items

            }
            if(!removal.isEmpty()) {
                lagerortEntity.getGegenstandLagerorte().removeAll(removal);
                lagerortRepository.save(lagerortEntity);
            }
        }
    }

	public List<Gegenstand> deleteItem(BigInteger heldid, int index) {
		HeldWithVersion heldWithVersion = heldRepositoryService.findHeldWithLatestVersion(heldid);
		securityUtils.canCurrentUserEditHeld(heldWithVersion.getHeld());
		UserEntity userEntity = userRepository.findById(heldWithVersion.getHeld().getUserId()).get();
		if(!userEntity.isCanWrite()) {
			throw new NoWritePermissionException();
		}
		Element items = getItemsElement(heldWithVersion);
		Gegenstand gegenstand = null;
		int idx = -0;
		for(int i = 0; i<items.getChildNodes().getLength(); i++) {
			Node node = items.getChildNodes().item(i);
			if(!(node instanceof Element)) {
				continue;
			}
			if(idx == index) {
				gegenstand = parseGegenstand(node);
				items.removeChild(node);

				break;
			}
			idx ++;
		}
		lagerortRepository.deleteByHeldidAndGegenstandLagerorteNameAndGegenstandLagerorteAmount(heldid,gegenstand.getGegenstand(), gegenstand.getAnzahl() );
		try {
			String xml = XmlUtil.toString(items.getOwnerDocument());
			if(xml == null) {
				throw new TransformerException("");
			}
			updateHeldXml(heldWithVersion, xml, userEntity);
		} catch (TransformerException e) {
			e.printStackTrace();
		}
		return getInventar(heldid);

	}

	public List<Gegenstand> addItem(BigInteger heldid, String name, int amount) {
		HeldWithVersion heldWithVersion = heldRepositoryService.findHeldWithLatestVersion(heldid);
		securityUtils.canCurrentUserEditHeld(heldWithVersion.getHeld());
		UserEntity userEntity = userRepository.findById(heldWithVersion.getHeld().getUserId()).get();
		if(!userEntity.isCanWrite()) {
			throw new NoWritePermissionException();
		}
		Element items = getItemsElement(heldWithVersion);
		Element item = items.getOwnerDocument().createElement("gegenstand");
		item.setAttribute("anzahl", amount + "");
		item.setAttribute("name", "Armreif");
		item.setAttribute("slot", "0");

		Element mod = items.getOwnerDocument().createElement("modallgemein");
		Element gewicht = items.getOwnerDocument().createElement("gewicht");
		gewicht.setAttribute("value", "10");
		mod.appendChild(gewicht);
		Element preis = items.getOwnerDocument().createElement("preis");
		preis.setAttribute("value", "10");
		mod.appendChild(preis);
		Element nameElement = items.getOwnerDocument().createElement("name");
		nameElement.setAttribute("value", name);
		mod.appendChild(nameElement);
		item.appendChild(mod);
		items.appendChild(item);
		String xml = XmlUtil.toString(items.getOwnerDocument());
		updateHeldXml(heldWithVersion, xml, userEntity);
		return getInventar(heldid);
	}

	public void updateHeldXml(HeldWithVersion heldWithVersion, String xml, UserEntity userEntity) {
		String token = userEntity.getToken();
		InputStream stream = new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8));
		heldenApi.getCacheHandler().doCache(new ReturnHeldXmlRequest(heldWithVersion.getHeld().getId(), null, heldWithVersion.getVersion().getCacheId()), stream);
		heldenApi.request(new UpdateXmlRequest(new TokenAuthentication(token), xml))
				.subscribe((data) -> log.info("Updated held xml {} {}", heldWithVersion.getHeld().getName(), heldWithVersion.getHeld().getId()));
	}

	public void lockHeld(HeldEntity heldEntity) {
		heldEntity.setLockExpire(new Date(System.currentTimeMillis() + 3600 * 1000));
		heldRepositoryService.saveHeld(heldEntity);
	}


	public List<Lagerort> getLagerorte(BigInteger heldid) {
		heldRepositoryService.findHeld(heldid);
		return lagerortRepository.findByHeldid(heldid)
				.stream()
				.map(lagerort -> {
					Lagerort dto = new Lagerort();
					dto.setName(lagerort.getName());
					dto.setId(lagerort.getId());
					dto.setNotizen(lagerort.getNotiz());
					return dto;
				}).collect(Collectors.toList());
	}

	public List<Lagerort> addLagerort(BigInteger heldid, String name, String notiz) {
		securityUtils.canCurrentUserEditHeld(heldRepositoryService.findHeld(heldid));
		LagerortEntity lagerortEntity = new LagerortEntity();
		lagerortEntity.setHeldid(heldid);
		lagerortEntity.setName(name);
		lagerortEntity.setNotiz(notiz);
		lagerortRepository.save(lagerortEntity);
		return getLagerorte(heldid);
	}

    public void setLagerort(BigInteger heldid, String from, String to, String gegenstand, int amount) {
	    HeldWithVersion heldWithVersion = heldRepositoryService.findHeldWithLatestVersion(heldid);
	    securityUtils.canCurrentUserEditHeld(heldWithVersion.getHeld());
	    LagerortEntity toOrt = lagerortRepository.findByNameAndHeldid(to, heldid);
	    if(from != null) {
	        LagerortEntity lagerortEntity = lagerortRepository.findByNameAndHeldid(from, heldid);
	        Optional<GegenstandLagerort> optional = lagerortEntity.getGegenstandLagerorte()
					.stream()
					.filter(e -> e.getAmount() == amount)
					.filter(e -> e.getName() == gegenstand)
					.findFirst()
					.map(e -> {
						lagerortEntity.getGegenstandLagerorte().remove(e);
						e.setLagerort(toOrt.getId());
						toOrt.getGegenstandLagerorte().add(e);
						lagerortRepository.save(toOrt);

						return e;
					});
	        return;
        }

	    GegenstandLagerort gegenstandLagerort = new GegenstandLagerort();
	    gegenstandLagerort.setLagerort(toOrt.getId());
	    gegenstandLagerort.setAmount(amount);
	    gegenstandLagerort.setName(gegenstand);
	    toOrt.getGegenstandLagerorte().add(gegenstandLagerort);
	    lagerortRepository.save(toOrt);

    }

	public void updateLagerortNotiz(int lagerort, String notiz) {
		LagerortEntity lagerortEntity = lagerortRepository.findById(lagerort).get();
		heldRepositoryService.findHeld(lagerortEntity.getHeldid());
		lagerortEntity.setNotiz(notiz);
		lagerortRepository.save(lagerortEntity);

	}

	public void addFavorisiertesTalent(String name, BigInteger heldid) {
		HeldEntity heldEntity = heldRepositoryService.findHeld(heldid);
		SecurityUtils.checkIsHeldOfCurrentUser(heldEntity);
		FavTalentEntity favTalentEntity = new FavTalentEntity();
		favTalentEntity.setName(name);
		favTalentEntity.setHeldid(heldid);
		favTalentRepository.save(favTalentEntity);
	}

	public void removeFavorisiertesTalent(String name, BigInteger heldid) {
		favTalentRepository.deleteByHeldidAndName(heldid, name);
	}

	public List<String> getFavorisierteTalente(BigInteger heldid) {
		heldRepositoryService.findHeld(heldid);
		return favTalentRepository.findByHeldid(heldid)
				.stream()
				.map(FavTalentEntity::getName)
				.collect(Collectors.toList());
	}

	public List<Object> getFavoriten(BigInteger heldid) {
		List<Object> list = new ArrayList<>();
		List<String> favorisierte = getFavorisierteTalente(heldid);
		HeldWithVersion heldWithVersion = heldRepositoryService.findHeldWithLatestVersion(heldid);

		Daten daten = heldenApi.request(new ReturnHeldDatenWithEreignisseRequest(heldid, null, heldWithVersion.getVersion().getCacheId()))
				.block();
		daten.getTalentliste()
				.getTalent()
				.stream()
				.filter(talent -> favorisierte.contains(talent.getName()))
				.forEach(talent -> {
					list.add(talent);
				});
		if(list.size() != 0 ) {
		    list.add(0, new RowGrouper("Talente"));
        }

		//TODO this can be a lot faster if implemented with more care. Do that if needed
        int preSize = list.size();
		daten.getZauberliste()
				.getZauber()
				.stream()
				.filter(zauber -> favorisierte.contains(zauber.getName()))
				.forEach(zauber -> {
					list.add(zauber);
				});
		if(preSize != list.size()) {
		    list.add(preSize, new RowGrouper("Zauber"));
        }

		return list;
	}
}
